<template>
  <div>
    <div ref="editor"></div>
  </div>
</template>

<script setup>
import { onMounted, ref, onBeforeUnmount } from 'vue'
import { EditorState } from 'prosemirror-state'
import { EditorView } from 'prosemirror-view'
import { DOMParser } from 'prosemirror-model'
import { schema as basicSchema } from 'prosemirror-schema-basic'
import { exampleSetup } from 'prosemirror-example-setup'
import { Plugin, PluginKey } from 'prosemirror-state'
import { Decoration, DecorationSet } from 'prosemirror-view'
import { showTooltip, hideTooltip } from '../utils/tooltip'
import 'prosemirror-example-setup/style/style.css'
import 'prosemirror-menu/style/menu.css'

const editor = ref(null)
let view = null

// Track ignored errors to prevent re-highlighting
const ignoredErrors = new Set()


/**
 * Split text into sentences using simple punctuation-based rules
 * @param {string} text - Text to split
 * @returns {Array<{text: string, offset: number}>} - Array of sentences with their offsets
 */
function splitIntoSentences(text) {
  const sentences = []
  const sentenceRegex = /[.!?]+/g
  let lastIndex = 0
  let match
  
  while ((match = sentenceRegex.exec(text)) !== null) {
    const endIndex = match.index + match[0].length
    const sentence = text.slice(lastIndex, endIndex).trim()
    
    if (sentence.length > 0) {
      sentences.push({
        text: sentence,
        offset: lastIndex
      })
    }
    
    lastIndex = endIndex
  }
  
  // Handle remaining text if no punctuation at the end
  const remaining = text.slice(lastIndex).trim()
  if (remaining.length > 0) {
    sentences.push({
      text: remaining,
      offset: lastIndex
    })
  }
  
  return sentences
}

// Cache for sentence syntax check results
const sentenceCache = new Map()

/**
 * ÁºìÂ≠ò grammar check API ÁöÑÂ∫îÁ≠î
 * @type {Map<string, Object>}
 */
const grammarCheckApiCache = new Map()

/**
 * Call the grammar check API for a sentence, with response caching.
 * @param {string} sentenceText
 * @returns {Promise<Object>} API response
 */
async function callGrammarCheckApi(sentenceText) {
  const cacheKey = sentenceText.trim()
  if (grammarCheckApiCache.has(cacheKey)) {
    return grammarCheckApiCache.get(cacheKey)
  }
  try {
    const resp = await fetch('/api/actions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sentence: sentenceText })
    })
    const data = await resp.json()
    grammarCheckApiCache.set(cacheKey, data)
    return data
  } catch (error) {
    console.error('Grammar check API failed:', error)
    throw error
  }
}

/**
 * Ëß£Êûê API ËøîÂõûÁöÑ actionsÔºåÁîüÊàê ranges
 * @param {Array} actions - APIËøîÂõûÁöÑactions
 * @param {number} sentenceAbsolutePos - Âè•Â≠êÂú®ÊñáÊ°£‰∏≠ÁöÑÁªùÂØπ‰ΩçÁΩÆ
 * @returns {Array}
 */
function parseApiActionsToRanges(actions, sentenceAbsolutePos) {
  const ranges = []
  for (const action of actions) {
    if (action.token_end !== undefined && action.token_start !== undefined) {
      const absoluteStart = sentenceAbsolutePos + action.token_start
      const absoluteEnd = sentenceAbsolutePos + action.token_end
      const errorKey = `${absoluteStart}-${absoluteEnd}-${action.original}`

      if (!ignoredErrors.has(errorKey)) {
        ranges.push({ 
          from: absoluteStart, 
          to: absoluteEnd,
          action: {
            ...action,
            absolute_token_start: absoluteStart,
            absolute_token_end: absoluteEnd
          }
        })
      }
    }
  }
  return ranges
}

/**
 * Fetch syntax check for individual sentence with caching
 * @param {string} sentenceText - Text content of the sentence
 * @param {number} sentenceAbsolutePos - Absolute position of the sentence in the document
 * @returns {Promise<Array>} - Error ranges with absolute positions
 */
async function fetchSentenceSyntaxCheck(sentenceText, sentenceAbsolutePos) {
  console.log('fetchSentenceSyntaxCheck:', sentenceText, 'at absolute position:', sentenceAbsolutePos)
  try {
    const data = await callGrammarCheckApi(sentenceText)
    const ranges = parseApiActionsToRanges(data.actions, sentenceAbsolutePos)
    return ranges
  } catch (error) {
    console.error('Sentence syntax check failed:', error)
    return []
  }
}

/**
 * Fetch syntax check for individual text node with sentence-based caching
 * @param {string} nodeText - Text content of the node
 * @param {number} nodePos - Position of the node in the document
 * @returns {Promise<Array>} - Error ranges with absolute positions
 */
async function fetchTextNodeSyntaxCheck(nodeText, nodePos) {
  console.log('fetchTextNodeSyntaxCheck:', nodeText, 'at position:', nodePos)
  const sentences = splitIntoSentences(nodeText)
  console.log('Split into sentences:', sentences)
  const allRanges = []
  const checkPromises = []
  for (const sentence of sentences) {
    const promise = fetchSentenceSyntaxCheck(sentence.text, nodePos + sentence.offset)
      .then(ranges => {
        allRanges.push(...ranges)
      })
      .catch(error => {
        console.error(`Failed to check sentence "${sentence.text}":`, error)
      })
    checkPromises.push(promise)
  }
  await Promise.all(checkPromises)
  console.log(`fetchTextNodeSyntaxCheck completed. Total ranges: ${allRanges.length}`)
  return allRanges
}

/**
 * Check syntax for all text nodes in the document
 * @param {Node} doc - ProseMirror document
 * @returns {Promise<Array>} - All error ranges across all text nodes
 */
async function checkAllTextNodes(doc) {
  const allRanges = []
  const checkPromises = []
  doc.descendants((node, pos) => {
    if (node.isText && node.text && node.text.trim()) {
      console.log(`checkAllTextNodes: pos=${pos}, node.type=${node.type.name}, node.text=[${node.text}]`)
      const promise = fetchTextNodeSyntaxCheck(node.text, pos)
        .then(ranges => {
          allRanges.push(...ranges)
        })
        .catch(error => {
          console.error(`Failed to check text node at position ${pos}:`, error)
        })
      checkPromises.push(promise)
    }
  })
  await Promise.all(checkPromises)
  console.log(`checkAllTextNodes completed. Total ranges: ${allRanges.length}, Cache size: ${grammarCheckApiCache.size}`)
  return allRanges
}

/**
 * Generate syntax error decorations with proper position mapping
 * @param {Node} doc - ProseMirror document
 * @param {Array} ranges - Error ranges with absolute positions
 * @returns {DecorationSet}
 */
function getSyntaxErrorDecorations(doc, ranges) {
  const decorations = []
  
  // Create decorations directly from absolute positions
  for (const range of ranges) {
    const { from, to, action } = range
    
    // Validate positions are within document bounds
    if (from >= 0 && to <= doc.content.size && from < to) {
      try {
        decorations.push(
          Decoration.inline(from, to, {
            class: 'syntax-error-highlight',
          }, {
            // Store in spec for internal access
            errorAction: action,
            errorRange: { from, to }
          })
        )
        console.log(`Created decoration: ${from}-${to} for "${action.original}"`)
      } catch (error) {
        console.error(`Failed to create decoration for range ${from}-${to}:`, error)
      }
    } else {
      console.warn(`Invalid range: ${from}-${to}, doc size: ${doc.content.size}`)
    }
  }
  
  return DecorationSet.create(doc, decorations)
}


/**
 * Apply suggestion with support for append, delete, and replace operations
 * @param {Object} action - Error action data
 * @param {Object} range - Error range in document
 */
function applySuggestion(action, range) {
  if (!action || !range || !view) {
    console.warn('No action, range, or view available')
    return
  }
  
  const { from, to } = range
  let tr
  
  try {
    if (action.action.startsWith('$APPEND_')) {
      // Append operation: insert text after the current position
      console.log('Append operation:', action.real_replacement, 'at position:', to)
      tr = view.state.tr.insert(to, view.state.schema.text(action.real_replacement))
    } else if (action.action === '$DELETE') {
      // Delete operation: remove the specified range
      console.log('Delete operation: removing range', from, 'to', to)
      tr = view.state.tr.delete(from, to)
    } else {
      // Replace operation: replace current range with real_replacement
      console.log('Replace operation:', action.original, '->', action.real_replacement)
      tr = view.state.tr.replaceWith(from, to, view.state.schema.text(action.real_replacement))
    }
    
    view.dispatch(tr)
    console.log('Successfully applied suggestion:', action.action)
  } catch (error) {
    console.error('Failed to apply suggestion:', error)
  }
  
  hideTooltip()
}

/**
 * Ignore suggestion - add to ignored list and remove highlighting
 * @param {Object} action - Error action data
 */
function ignoreSuggestion(action) {
  if (!action) return

  const errorKey = `${action.absolute_token_start}-${action.absolute_token_end}-${action.original}`
  ignoredErrors.add(errorKey)
  
  
  // Trigger re-check to update decorations
  if (view) {
    checkAllTextNodes(view.state.doc).then(ranges => {
      const deco = getSyntaxErrorDecorations(view.state.doc, ranges)
      const tr = view.state.tr.setMeta('syntax-check-update', deco)
      view.dispatch(tr)
    }).catch(console.error)
  }
  
  hideTooltip()
}

/**
 * ÂàÜÊûêÂπ∂ÊâìÂç∞ÊñáÊ°£ÂèòÂåñ‰∏≠ÁöÑÊñáÊú¨ËäÇÁÇπ‰øÆÊîπ‰ø°ÊÅØ
 * @param {Transaction} tr - ProseMirror‰∫ãÂä°
 * @param {Node} oldDoc - ‰øÆÊîπÂâçÁöÑÊñáÊ°£
 * @param {Node} newDoc - ‰øÆÊîπÂêéÁöÑÊñáÊ°£
 */
function analyzeTextNodeChanges(tr, oldDoc, newDoc) {
  if (!tr.docChanged) return

  console.group('üìù Text Node Changes Detected')
  
  // ÈÅçÂéÜ‰∫ãÂä°‰∏≠ÁöÑÊâÄÊúâÊ≠•È™§
  tr.steps.forEach((step, stepIndex) => {
    console.log(`\n--- Step ${stepIndex + 1} ---`)
    console.log('Step type:', step.constructor.name)
    console.log('Step JSON:', step.toJSON())
    
    if (step.from !== undefined && step.to !== undefined) {
      /*
      fromÂíåto ÈÄöÂ∏∏ÊåáÁöÑÊòØ ProseMirror ÁöÑ‚ÄúÊ≠•È™§‚ÄùÔºàstepÔºâÂØπË±°‰∏≠ÁöÑ‰ΩçÁΩÆ„ÄÇ
      ÂÆÉ‰ª¨Ë°®Á§∫Âú®ÊñáÊ°£‰∏≠Ë¶ÅÂ∫îÁî®Êõ¥ÊîπÁöÑËµ∑Âßã‰ΩçÁΩÆÔºàfromÔºâÂíåÁªìÊùü‰ΩçÁΩÆÔºàtoÔºâ„ÄÇ

      ÂÖ∑‰ΩìÊù•ËØ¥Ôºö

      fromÔºöÊõ¥ÊîπÂºÄÂßãÁöÑ‰ΩçÁΩÆÔºàÂÅèÁßªÈáèÔºåÈÄöÂ∏∏ÊòØÂ≠óÁ¨¶ÊàñËäÇÁÇπÁ¥¢ÂºïÔºâ„ÄÇ
      toÔºöÊõ¥ÊîπÁªìÊùüÁöÑ‰ΩçÁΩÆ„ÄÇ
      Ëøô‰∏§‰∏™‰ΩçÁΩÆÊòØÈíàÂØπ**ÊóßÊñáÊ°£ÔºàoldDocÔºâ**ÁöÑÔºåÂõ†‰∏∫Ê≠•È™§ÔºàstepÔºâÊòØÂú®ÊóßÊñáÊ°£‰∏äÂÆö‰πâÁöÑÊìç‰ΩúÔºå
      Â∫îÁî®ÂêéÊâçÂæóÂà∞Êñ∞ÊñáÊ°£ÔºànewDocÔºâ„ÄÇ
      Êç¢Âè•ËØùËØ¥Ôºåstep ÁöÑ from Âíå to ÊòØÊèèËø∞Â¶Ç‰Ωï‰ªé oldDoc ÂèòÊàê newDoc ÁöÑ‰ΩçÁΩÆËåÉÂõ¥„ÄÇ

      Ë°•ÂÖÖËØ¥ÊòéÔºö
      Â¶ÇÊûú‰Ω†Âú®Â§ÑÁêÜ ProseMirror ÁöÑ transaction Êàñ stepÔºå
      ÈÄöÂ∏∏Ëøô‰∫õ‰ΩçÁΩÆÈÉΩÊòØÂü∫‰∫éÂ∫îÁî®Êõ¥ÊîπÂâçÁöÑÊñáÊ°£ÔºàÂç≥ oldDocÔºâ„ÄÇ      
      */
      const from = step.from
      const to = step.to
      
      console.log(`Position range: ${from} ‚Üí ${to}`)
      // Âè™Êî∂ÈõÜ from Âíå to ‰πãÈó¥ÁöÑÊâÄÊúâËäÇÁÇπ
      const nodesBetween = []

      oldDoc.descendants((node, pos, parent) => {
        if (pos + node.nodeSize > from && pos < to) {
          nodesBetween.push({ node, pos, parent })
        }
      })

      // ËæìÂá∫ from Âíå to ‰πãÈó¥ÁöÑÊâÄÊúâËäÇÁÇπ‰ø°ÊÅØ
      console.log('Nodes between from and to:', nodesBetween.map(info => ({
        type: info.node.type.name,
        pos: info.pos,
        text: info.node.isText ? info.node.text : null,
        nodeSize: info.node.nodeSize
      })))
      
      // Ëé∑Âèñ‰øÆÊîπÂâçÁöÑÂÜÖÂÆπ
      if (from <= oldDoc.content.size && to <= oldDoc.content.size) {
        const oldSlice = oldDoc.slice(from, to)
        console.log('Old content:', {
          size: oldSlice.size,
          content: oldSlice.content.toString(),
          textContent: oldSlice.content.textBetween(0, oldSlice.content.size)
        })
        
        // ÂàÜÊûêÊóßÂÜÖÂÆπ‰∏≠ÁöÑËäÇÁÇπ
        oldSlice.content.forEach((node, offset) => {
          console.log(`  Old node at offset ${offset}:`, {
            type: node.type.name,
            isText: node.isText,
            content: node.isText ? `"${node.text}"` : node.content.toString(),
            size: node.nodeSize
          })
        })
      }
      
      // Ëé∑Âèñ‰øÆÊîπÂêéÁöÑÂÜÖÂÆπÔºàÂ¶ÇÊûúÊòØÊõøÊç¢Êìç‰ΩúÔºâ
      if (step.slice) {
        const newSlice = step.slice
        console.log('New content:', {
          size: newSlice.size,
          content: newSlice.content.toString(),
          textContent: newSlice.content.textBetween(0, newSlice.content.size)
        })
        
        // ÂàÜÊûêÊñ∞ÂÜÖÂÆπ‰∏≠ÁöÑËäÇÁÇπ
        newSlice.content.forEach((node, offset) => {
          console.log(`  New node at offset ${offset}:`, {
            type: node.type.name,
            isText: node.isText,
            content: node.isText ? `"${node.text}"` : node.content.toString(),
            size: node.nodeSize
          })
        })
      }
    }
  })
  
  // È¢ùÂ§ñÂàÜÊûêÔºöÊØîËæÉÊï¥‰∏™ÊñáÊ°£ÁöÑÊñáÊú¨ËäÇÁÇπÂèòÂåñ
  console.log('\n--- Document Text Nodes Comparison ---')
  const oldTextNodes = extractTextNodes(oldDoc)
  const newTextNodes = extractTextNodes(newDoc)
  
  console.log('Old text nodes:', oldTextNodes)
  console.log('New text nodes:', newTextNodes)
  
  // ÊâæÂá∫ÂèòÂåñÁöÑÊñáÊú¨ËäÇÁÇπ
  const changes = findTextNodeChanges(oldTextNodes, newTextNodes)
  if (changes.length > 0) {
    console.log('Detected text node changes:', changes)
  }
  
  console.groupEnd()
}

/**
 * ÊèêÂèñÊñáÊ°£‰∏≠ÊâÄÊúâÊñáÊú¨ËäÇÁÇπÁöÑ‰ø°ÊÅØ
 * @param {Node} doc - ProseMirrorÊñáÊ°£
 * @returns {Array} ÊñáÊú¨ËäÇÁÇπ‰ø°ÊÅØÊï∞ÁªÑ
 */
function extractTextNodes(doc) {
  const textNodes = []
  
  doc.descendants((node, pos) => {
    if (node.isText) {
      textNodes.push({
        position: pos,
        text: node.text,
        length: node.text.length,
        type: node.type.name
      })
    }
  })
  
  return textNodes
}

/**
 * ÊØîËæÉ‰∏§ÁªÑÊñáÊú¨ËäÇÁÇπÔºåÊâæÂá∫ÂèòÂåñ
 * @param {Array} oldNodes - ‰øÆÊîπÂâçÁöÑÊñáÊú¨ËäÇÁÇπ
 * @param {Array} newNodes - ‰øÆÊîπÂêéÁöÑÊñáÊú¨ËäÇÁÇπ
 * @returns {Array} ÂèòÂåñ‰ø°ÊÅØÊï∞ÁªÑ
 */
function findTextNodeChanges(oldNodes, newNodes) {
  const changes = []
  
  // ÁÆÄÂçïÁöÑÂèòÂåñÊ£ÄÊµãÔºöÊØîËæÉÊï∞ÈáèÂíåÂÜÖÂÆπ
  if (oldNodes.length !== newNodes.length) {
    changes.push({
      type: 'count_change',
      oldCount: oldNodes.length,
      newCount: newNodes.length
    })
  }
  
  // ÊØîËæÉÁõ∏Âêå‰ΩçÁΩÆÁöÑËäÇÁÇπÂÜÖÂÆπ
  const maxLength = Math.max(oldNodes.length, newNodes.length)
  for (let i = 0; i < maxLength; i++) {
    const oldNode = oldNodes[i]
    const newNode = newNodes[i]
    
    if (!oldNode && newNode) {
      changes.push({
        type: 'added',
        index: i,
        node: newNode
      })
    } else if (oldNode && !newNode) {
      changes.push({
        type: 'removed',
        index: i,
        node: oldNode
      })
    } else if (oldNode && newNode && oldNode.text !== newNode.text) {
      changes.push({
        type: 'modified',
        index: i,
        oldNode: oldNode,
        newNode: newNode,
        oldText: oldNode.text,
        newText: newNode.text
      })
    }
  }
  
  return changes
}

/**
 * ËØ≠Ê≥ïÊ£ÄÊü•ÂºÇÊ≠•Êèí‰ª∂
 */
function createSyntaxCheckPlugin() {
  let currentDeco = DecorationSet.empty
  return new Plugin({
    key: syntaxPluginKey,
    state: {
      init(_, { doc }) {
        currentDeco = DecorationSet.empty
        return currentDeco
      },
      /**
       * Applies a transformation to the editor state.
       * 
       * @param {Transaction} tr - The ProseMirror transaction object representing changes to be applied.
       * @param {any} old - The previous value or state before the transaction.
       * @param {EditorState} oldState - The previous ProseMirror editor state.
       * @param {EditorState} newState - The new ProseMirror editor state after the transaction.
       * @returns {any} The updated value or state after applying the transaction.
       */
      apply(tr, old, oldState, newState) {
        // üÜï Ê∑ªÂä†ÊñáÊú¨ËäÇÁÇπÂèòÂåñÂàÜÊûê
        //if (tr.docChanged) {
        //  analyzeTextNodeChanges(tr, oldState.doc, newState.doc)
        //}

        const newDeco = tr.getMeta('syntax-check-update')
        if (newDeco) {
          // ‰ΩøÁî®ËØ≠Ê≥ïÊ£ÄÊü•ËøîÂõûÁöÑÊñ∞Ë£ÖÈ•∞ÈõÜÂêà
          currentDeco = newDeco
          return currentDeco
        }
        if (tr.docChanged) {
          // ÊñáÊ°£ÂÜÖÂÆπÊúâÂèòÂåñÊó∂ÔºåÊ∏ÖÁ©∫Ë£ÖÈ•∞
          currentDeco = DecorationSet.empty
          return currentDeco
        }
        // ‰øùÊåÅÂéüÊúâË£ÖÈ•∞
        return currentDeco
      }
    },
    view(editorView) {
      let timeout = null
      let destroyed = false
      
      async function check() {
        if (destroyed) return
        try {
          const ranges = await checkAllTextNodes(editorView.state.doc)
          if (destroyed) return
          const deco = getSyntaxErrorDecorations(editorView.state.doc, ranges)
          const tr = editorView.state.tr.setMeta('syntax-check-update', deco)
          editorView.dispatch(tr)
        } catch (e) {
          console.error('Syntax check error:', e)
        }
      }
      
      /**
       * Âª∂Ëøü400msÂêéÊâßË°å `check` ÂáΩÊï∞ÔºåÂ¶ÇÊûúÂú®ËøôÊÆµÊó∂Èó¥ÂÜÖÂÜçÊ¨°Ë∞ÉÁî®ÔºåÂàô‰ºöÊ∏ÖÈô§‰∏ä‰∏ÄÊ¨°ÁöÑÂÆöÊó∂Âô®Ôºå
       * ‰øùËØÅ `check` Âè™‰ºöÂú®ÊúÄÂêé‰∏ÄÊ¨°Ë∞ÉÁî®ÂêéÊâßË°å‰∏ÄÊ¨°„ÄÇ
       * ‰∏ªË¶ÅÁî®‰∫éÈò≤ÊäñÂ§ÑÁêÜÔºåÊØîÂ¶ÇÁî®Êà∑ËæìÂÖ•Á≠âÈ´òÈ¢ë‰∫ã‰ª∂„ÄÇ
       */
      function scheduleCheck() {
        if (timeout) clearTimeout(timeout)
        timeout = setTimeout(check, 400)
      }
      
      /**
       * Handle click events with improved positioning using ProseMirror coordinates
       */
      function handleClick(view, pos, event) {
       
        // Check if we clicked on a syntax error highlight
        const clickedElement = event.target
        // ‰ΩøÁî® closest ÊñπÊ≥ïÊü•ÊâæÊúÄËøëÁöÑËØ≠Ê≥ïÈîôËØØÈ´ò‰∫ÆÂÖÉÁ¥†
        const syntaxErrorElement = clickedElement.closest('.syntax-error-highlight')
        if (!syntaxErrorElement) {
          hideTooltip()
          return false
        }
        
        // Prevent default since we found our target
        event.preventDefault()
        event.stopPropagation()
        
        // Get decorations at the clicked position
        const decorations = syntaxPluginKey.getState(view.state)
        if (!decorations || decorations.isEmpty) {
          hideTooltip()
          return false
        }
        
        // Find decoration at clicked position
        const foundDecorations = decorations.find(pos, pos)
        console.log('Found decorations at position:', foundDecorations)
        
        for (const decoration of foundDecorations) {
          const spec = decoration.spec
          console.log('Decoration spec:', spec)
          
          // Check if this is a syntax error decoration
          if (spec && spec.errorAction && spec.errorRange) {
            console.log('Found syntax error decoration:', spec.errorAction)
            console.log('Range for positioning:', spec.errorRange)
            
            // Use extracted tooltip utility
            showTooltip(
              spec.errorAction, 
              spec.errorRange, 
              syntaxErrorElement, 
              view,
              applySuggestion,
              ignoreSuggestion
            )
            return true
          }
        }
        
        hideTooltip()
        return false
      }
      
      /**
       * Êõ¥Êñ∞ ProseMirror ÁºñËæëÂô®ÁöÑÂ±ûÊÄßÔºö
       * - handleDOMEvents.input: ÂΩìËæìÂÖ•‰∫ã‰ª∂ÂèëÁîüÊó∂ÔºåË∞ÉÁî® scheduleCheck() ËøõË°åÊ£ÄÊü•ÔºåÂπ∂ËøîÂõû false ‰ª•ÂÖÅËÆ∏ÈªòËÆ§Â§ÑÁêÜ„ÄÇ
       * - handleClick: ËÆæÁΩÆËá™ÂÆö‰πâÁÇπÂáª‰∫ã‰ª∂Â§ÑÁêÜÂáΩÊï∞„ÄÇ
       */
      editorView.setProps({
        handleDOMEvents: {
          /*
          DOM‰∫ã‰ª∂È©±Âä®: Áõ¥Êé•ÂìçÂ∫îÊµèËßàÂô®ÁöÑÂéüÁîü input DOM‰∫ã‰ª∂
          Êõ¥Êó©Ëß¶Âèë: Âú®Áî®Êà∑ÈîÆÁõòËæìÂÖ•„ÄÅÁ≤òË¥¥Á≠âÊìç‰ΩúÊó∂Á´ãÂç≥Ëß¶Âèë
          Êõ¥ÂπøÊ≥õË¶ÜÁõñ: ÊçïËé∑ÊâÄÊúâÂèØËÉΩÁöÑËæìÂÖ•Êìç‰ΩúÔºåÂåÖÊã¨‰∏Ä‰∫õProseMirrorÂèØËÉΩÊú™ÂÆåÂÖ®Â§ÑÁêÜÁöÑËæπÁºòÊÉÖÂÜµ
          DOMÂ±ÇÈù¢: Âú®DOM‰∫ã‰ª∂Â±ÇÈù¢Â∑•‰Ωú
          */
          input: () => { 
            scheduleCheck(); 
            return false 
          }
        },
        handleClick: handleClick
      })
      /*
      ËøôÈáåË∞ÉÁî® scheduleCheck() ÈÄöÂ∏∏ÊòØ‰∏∫‰∫ÜÂú®ÁªÑ‰ª∂ÂàùÂßãÂåñÊó∂ËøõË°å‰∏ÄÊ¨°ÊñáÊú¨Ê£ÄÊü•„ÄÇ
      ËøôÊ†∑ÂèØ‰ª•Á°Æ‰øùÈ°µÈù¢ÂàöÂä†ËΩΩÊàñÂÜÖÂÆπÂàöÊ∏≤ÊüìÊó∂ÔºåÁî®Êà∑ÁúãÂà∞ÁöÑÊñáÊú¨Â∑≤ÁªèË¢´Ê£ÄÊü•ËøáËØ≠Ê≥ïÊàñÈîôËØØÔºåËÄå‰∏çÊòØÁ≠âÂà∞Áî®Êà∑Êìç‰ΩúÂêéÊâçÂºÄÂßãÊ£ÄÊü•„ÄÇ

      Â∏∏ËßÅÂú∫ÊôØÔºö
      - È°µÈù¢È¶ñÊ¨°Âä†ËΩΩÊó∂Ëá™Âä®Ê£ÄÊü•Â∑≤ÊúâÂÜÖÂÆπ„ÄÇ
      - ÂàùÂßãÂåñÁºñËæëÂô®Êó∂Á°Æ‰øùÂÜÖÂÆπÁä∂ÊÄÅÊòØÊúÄÊñ∞ÁöÑ„ÄÇ
      
      Ê≥®ÊÑè‰∫ãÈ°πÔºö
      - Â¶ÇÊûú scheduleCheck() ÈáåÊúâÂºÇÊ≠•Êìç‰ΩúÊàñ‰æùËµñ‰∫éÊüê‰∫õÊï∞ÊçÆÔºåÂª∫ËÆÆÊîæÂú®ÂêàÈÄÇÁöÑÁîüÂëΩÂë®ÊúüÈí©Â≠êÔºàÂ¶Ç onMountedÔºâÈáåË∞ÉÁî®„ÄÇ
      - Â¶ÇÊûúÂÜÖÂÆπ‰∏∫Á©∫Êàñ‰∏çÈúÄË¶ÅÊ£ÄÊü•ÔºåÂèØ‰ª•Âä†Êù°‰ª∂Âà§Êñ≠ÔºåÈÅøÂÖçÊó†ÊïàÊ£ÄÊü•„ÄÇ
      */
      scheduleCheck()
      
      return {
        /*
        Ëøô‰∏™ update(view, prevState) ÂáΩÊï∞ÈÄöÂ∏∏ÊòØ ProseMirror Êèí‰ª∂ÁöÑ view ÁîüÂëΩÂë®ÊúüÈí©Â≠ê‰πã‰∏Ä„ÄÇÂÆÉ‰ºöÂú®ÁºñËæëÂô®ÁöÑÁä∂ÊÄÅÂèëÁîüÂèòÂåñÊó∂Ë¢´Ë∞ÉÁî®ÔºåÊØîÂ¶ÇÔºö

        - Áî®Êà∑ËæìÂÖ•ÊàñÂà†Èô§ÊñáÊú¨
        - ÊñáÊ°£ÂÜÖÂÆπÂèëÁîüÂèòÊõ¥ÔºàÂ¶ÇÊèíÂÖ•„ÄÅÂà†Èô§ËäÇÁÇπÔºâ
        - ÁºñËæëÂô®Áä∂ÊÄÅÔºàÂ¶Ç selection„ÄÅmarksÔºâÂèëÁîüÂèòÂåñ

        Âè™ÊúâÂΩìÊñáÊ°£ÂÜÖÂÆπÔºàdocÔºâÂèëÁîüÂèòÂåñÊó∂ÔºåÊâç‰ºöÊâßË°å scheduleCheck()„ÄÇËøôÊÑèÂë≥ÁùÄÔºö
        - Áî®Êà∑ÂÆûÈôÖ‰øÆÊîπ‰∫ÜÊñáÊú¨ÂÜÖÂÆπÊó∂‰ºöËß¶Âèë
        - ÂÖâÊ†áÁßªÂä®„ÄÅÊ†∑ÂºèÂèòÂåñ‰ΩÜÂÜÖÂÆπÊú™ÂèòÊó∂‰∏ç‰ºöËß¶Âèë
        
        ÁâπÁÇπÔºö
        - Áä∂ÊÄÅÂèòÂåñÈ©±Âä®: ÂìçÂ∫îProseMirrorÊñáÊ°£Áä∂ÊÄÅÁöÑÂèòÂåñ
        - ÊúâÊù°‰ª∂Ëß¶Âèë: Âè™ÊúâÂΩìÊñáÊ°£ÂÜÖÂÆπÁúüÊ≠£ÊîπÂèòÊó∂ÊâçËß¶ÂèëÔºàview.state.doc !== prevState.docÔºâ
        - Êõ¥Á≤æÁ°Æ: ËøáÊª§ÊéâÂÖâÊ†áÁßªÂä®„ÄÅÈÄâÊã©ÂèòÂåñÁ≠â‰∏çÂΩ±ÂìçÂÜÖÂÆπÁöÑÊìç‰Ωú
        - ProseMirrorÂ±ÇÈù¢: Âú®ÁºñËæëÂô®Áä∂ÊÄÅÂ±ÇÈù¢Â∑•‰Ωú

        ‰∏∫‰ªÄ‰πàÈúÄË¶Å‰∏§‰∏™ÔºàhandleDOMEvents.inputÂíåupdate(view, prevState)ÔºâÔºü
        - ÂÜó‰Ωô‰øùÈöú: Èò≤Ê≠¢Êüê‰∫õËæπÁºòÊÉÖÂÜµ‰∏ãÁöÑÈÅóÊºè
        - ‰∏çÂêåËß¶ÂèëÊó∂Êú∫: DOM‰∫ã‰ª∂ÂèØËÉΩÊØîÁä∂ÊÄÅÊõ¥Êñ∞Êõ¥Êó©Ëß¶Âèë
        - ‰∏çÂêåË¶ÜÁõñËåÉÂõ¥: DOM‰∫ã‰ª∂Ë¶ÜÁõñÊõ¥ÂπøÔºåÁä∂ÊÄÅÊ£ÄÊü•Êõ¥Á≤æÁ°Æ
        - Èò≤ÊäñÊú∫Âà∂: Áî±‰∫é scheduleCheck ÂÜÖÈÉ®Êúâ400msÈò≤ÊäñÔºåÂ§öÊ¨°Ë∞ÉÁî®‰∏ç‰ºöÈÄ†ÊàêÊÄßËÉΩÈóÆÈ¢ò

        Âç≥‰Ωø‰∏§‰∏™Âú∞ÊñπÈÉΩË∞ÉÁî®ÔºåÊúÄÁªàÂè™‰ºöÂú®ÊúÄÂêé‰∏ÄÊ¨°Ë∞ÉÁî®ÁöÑ400msÂêéÊâßË°å‰∏ÄÊ¨°Ê£ÄÊü•Ôºå
        Á°Æ‰øù‰∫ÜÊÄßËÉΩ‰ºòÂåñÁöÑÂêåÊó∂Êèê‰æõ‰∫ÜÂèØÈù†ÁöÑËß¶Âèë‰øùÈöú„ÄÇ
        */
        update(view, prevState) {
          if (view.state.doc !== prevState.doc) {
            scheduleCheck()
          }
        },
        destroy() {
          destroyed = true
          if (timeout) clearTimeout(timeout)
          hideTooltip()
        }
      }
    }
  })
}

/**
 * ÂêàÂπ∂ÊâÄÊúâÊèí‰ª∂ÁöÑË£ÖÈ•∞ÈõÜÂêà
 */
function combineDecorationsPlugin() {
  return new Plugin({
    key: new PluginKey('combine-decorations'),
    props: {
      decorations(state) {
        let decos = []
        
        // syntax check
        const syntax = syntaxPluginKey.get(state)
        //console.log('Syntax check decorations:', syntax)
        if (syntax) {
          const d = syntax.getState(state)
          if (d && !d.isEmpty) decos.push(d)
        }

        if (decos.length === 0) return null
        if (decos.length === 1) return decos[0]
        let result = decos[0]
        for (let i = 1; i < decos.length; ++i) {
          result = result.add(state.doc, result.find().concat(decos[i].find()))
        }
        return result
      }
    }
  })
}

const syntaxPluginKey = new PluginKey('syntax-check')

onMounted(() => {
  // ÂÆö‰πâÂàùÂßãÂåñÂÜÖÂÆπ
  const initialContent = document.createElement('div')
  initialContent.innerHTML = '<p>hello world, my name is a lili.</p><p>here¬†is a apple.</p>'

  // ÂàõÂª∫ÁºñËæëÂô®Áä∂ÊÄÅ
  const state = EditorState.create({
    doc: DOMParser.fromSchema(basicSchema).parse(initialContent),
    plugins: [
      ...exampleSetup({ schema: basicSchema }),
      createSyntaxCheckPlugin(),
      combineDecorationsPlugin(),
    ]
  })

  // ÂàõÂª∫ÁºñËæëÂô®ËßÜÂõæ
  view = new EditorView(editor.value, {
    state,
    dispatchTransaction(tr) {
      const newState = view.state.apply(tr)
      view.updateState(newState)
    }
  })
})

onBeforeUnmount(() => {
  hideTooltip()
  if (view) {
    view.destroy()
    view = null
  }
})
</script>

<style>
.ProseMirror {
  min-height: 200px;
  border: 1px solid #ccc;
  padding: 10px;
  outline: none;
  width: 600px;
  text-align: left;
}


.syntax-error-highlight {
  background: #ffb3b3;
  border-bottom: 2px solid red;
  cursor: pointer;
  position: relative;
}

.syntax-error-highlight:hover {
  background: #ff9999;
}

/* Tippy.js theme for syntax corrections */
.tippy-box[data-theme~='syntax-correction'] {
  background: white;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
  font-size: 14px;
  max-width: 300px;
}

.tippy-box[data-theme~='syntax-correction'] .tippy-content {
  padding: 16px;
}

.tippy-box[data-theme~='syntax-correction'] .tippy-arrow {
  color: white;
}

/* Tooltip content styles */
.tooltip-content {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.action-info {
  padding: 8px;
  border-radius: 6px;
  border-left: 4px solid;
}

.action-info.append {
  background: #f0f9ff;
  border-left-color: #0ea5e9;
}

.action-info.delete {
  background: #fef2f2;
  border-left-color: #ef4444;
}

.action-info.replace {
  background: #fffbeb;
  border-left-color: #f59e0b;
}

.action-type {
  font-weight: 600;
  font-size: 13px;
  margin-bottom: 6px;
  color: #374151;
}

.error-info, .suggestion-info, .reason-info {
  margin: 4px 0;
  word-break: break-word;
  line-height: 1.4;
  color: #374151; /* Darker text color for better readability */
}

.error-info strong, .suggestion-info strong {
  color: #111827; /* Even darker for the labels */
  font-weight: 600;
}

.reason-info {
  font-size: 12px;
  color: #4b5563; /* Darker than the previous light gray */
  font-style: italic;
}

.confidence-info {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: #6b7280;
}

.confidence-label {
  min-width: 50px;
}

.confidence-bar {
  flex: 1;
  height: 6px;
  background: #e5e7eb;
  border-radius: 3px;
  overflow: hidden;
}

.confidence-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.3s ease;
}

.confidence-fill.confidence-high {
  background: #10b981;
}

.confidence-fill.confidence-medium {
  background: #f59e0b;
}

.confidence-fill.confidence-low {
  background: #ef4444;
}

.confidence-value {
  min-width: 35px;
  text-align: right;
  font-weight: 500;
}

.tooltip-actions {
  display: flex;
  gap: 8px;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid #e5e7eb;
}

.btn-apply, .btn-ignore {
  flex: 1;
  padding: 6px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  background: white;
  cursor: pointer;
  font-size: 12px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.btn-apply {
  background: #3b82f6;
  color: white;
  border-color: #3b82f6;
}

.btn-apply:hover {
  background: #2563eb;
  border-color: #2563eb;
}

.btn-ignore:hover {
  background: #f9fafb;
  border-color: #9ca3af;
}
</style>